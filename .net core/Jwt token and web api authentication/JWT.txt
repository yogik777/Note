How Authentication Works: Step-by-Step
======================================
1.User Requests Access:
    A user attempts to access a secured resource, such as logging in via a login form or
    accessing an API endpoint.
2.Credentials Submission:
    The user provides credentials (e.g., username and password, API token, etc.) to the 
    system for verification.
3.Authentication Backend:
    The system sends the credentials to the authentication backend (e.g., database, 
    identity server, external service like OAuth).
4.Validation:
    The backend validates the credentials. For example:
        Checks if the username exists.
        Verifies if the provided password matches the stored (hashed) password.
    If valid, it authenticates the user; if invalid, it rejects the request. 
5.Session or Token Generation:
    If authentication is successful:
        A session or token is created to represent the user's authenticated state.
        Tokens could be:    
            JWT (JSON Web Token): A self-contained, signed token.
            Opaque Token: A simple, random identifier stored in the backend.   
        Sessions are often stored in memory, cookies, or distributed caches.


6.Response to the Client:
    The system sends back a response to the client, including:
        A session ID (in a cookie).
        An access token (in the response body or headers).

7.Subsequent Requests:
    The client includes the session ID or token in subsequent requests (e.g., in a 
        cookie or Authorization header).
    The server validates the session ID or token to verify the user's identity for each request.

8.Authorization (Post Authentication):
    After authentication, authorization ensures the authenticated user has the necessary
    permissions to access the requested resource.


Types of Authentication
-----------------------
Password-Based Authentication:
    User provides a username and password.
    Password is securely hashed and compared with stored hashes.

Token-Based Authentication:
    Access Tokens are issued after successful login (e.g., JWT, OAuth tokens).
    The token is sent with each request for resource access.

Multi-Factor Authentication (MFA):
    Combines two or more methods, such as:
        Something you know (password).
        Something you have (authenticator app, OTP).
        Something you are (biometrics).

OAuth and OpenID Connect:
    OAuth is used for delegation (e.g., "Log in with Google").
    OpenID Connect builds on OAuth for authentication (e.g., user profile and identity).

Certificate-Based Authentication:
    Digital certificates verify identity, often used in systems requiring high security 
    (e.g., enterprise systems).


How JWT Authentication Works
============================
1. Client Sends Credentials:
    The client sends their credentials (e.g., username and password) to the server's 
    authentication endpoint.

2.Server Verifies Credentials:
    The server validates the credentials against a database or another identity provider.

3.JWT Generation:
    If the credentials are valid, the server generates a JWT containing claims about 
        the user (e.g., user ID, roles).
    The token is signed using a secret (HMAC) or a private key (RSA/ECDSA).
4.Client Stores JWT:
    The client receives the JWT and stores it securely (e.g., in localStorage, 
        sessionStorage, or cookies).
5.Client Includes JWT in Requests:
    The client includes the JWT in the Authorization header of every subsequent request:
        Authorization: Bearer <JWT>
6.Authorization: Bearer <JWT>
    The server validates the JWT signature and extracts claims to identify the user and 
        authorize access.
7.Access Granted or Denied:
    If the token is valid and the user has the necessary permissions, the request is 
        processed; otherwise, access is denied.

Structure of a JWT
------------------
A JWT has three parts:
1.Header: Specifies the signing algorithm and token type.
    {
    "alg": "HS256",
    "typ": "JWT"
    }

2.Payload: Contains claims about the user or session.
    {
    "sub": "1234567890",
    "name": "John Doe",
    "roles": ["Admin", "User"],
    "exp": 1700000000
    }


3.Signature: Used to verify the token's authenticity.
    HMACSHA256(
        base64UrlEncode(header) + "." +
        base64UrlEncode(payload),
        secret
    )

A JWT looks like this:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZXMiOlsiQWRtaW4iLCJVc2VyIl0sImV4cCI6MTcwMDAwMDAwMH0.abc123signature

Advantages of JWT
-----------------
Stateless:
No need to store session data on the server.

Portable:
Can be used across multiple services and domains.

Secure:
Supports strong encryption and signing.

Compact:
Easy to transmit over networks (e.g., HTTP headers).



Implementing JWT Authentication in .NET Core
============================================
1. Install NuGet Packages
    dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer

2. Configure JWT Authentication in Startup.cs
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
        })
        .AddJwtBearer(options =>
        {
            options.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true,
                ValidateAudience = true,
                ValidateLifetime = true,
                ValidateIssuerSigningKey = true,
                ValidIssuer = "yourIssuer",
                ValidAudience = "yourAudience",
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("yourSecretKey"))
            };
        });

        services.AddControllers();
    }


3. Generate JWT in Controller
    [HttpPost("login")]
    public IActionResult Login([FromBody] LoginModel model)
    {
        if (model.Username == "user" && model.Password == "password")
        {
            var claims = new[]
            {
                new Claim(JwtRegisteredClaimNames.Sub, model.Username),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
                new Claim("role", "User")
            };

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("yourSecretKey"));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var token = new JwtSecurityToken(
                issuer: "yourIssuer",
                audience: "yourAudience",
                claims: claims,
                expires: DateTime.Now.AddMinutes(30),
                signingCredentials: creds);

            return Ok(new { token = new JwtSecurityTokenHandler().WriteToken(token) });
        }

        return Unauthorized();
    }


4. Protect Endpoints
    Add the [Authorize] attribute to secure endpoints.
    [Authorize]
    [HttpGet("secure-data")]
    public IActionResult GetSecureData()
    {
        return Ok("This is protected data.");
    }

5. Testing the JWT Flow
    Use tools like Postman to:
    Send login credentials to /login and retrieve the token.
    Include the token in the Authorization header for subsequent requests:

    Authorization: Bearer <JWT>


1.Use HTTPS:
Always transmit JWTs over encrypted connections.

2.Keep Secrets Safe:
Store signing keys securely and rotate them regularly.

3.Set Token Expiry:
Limit token validity to reduce exposure if compromised.

4.Use Refresh Tokens:
Allow users to obtain new tokens without re-authenticating.

5.Restrict Claims:
Include only necessary information in the token payload.

Role-Based Authorization with JWT Token
---------------------------------------
    Role-based authorization allows you to control access to resources based on the user's roles. Using JWT 
    tokens, you can embed the user's roles into the token and then enforce role-based policies in your 
    application.

Steps to Implement Role-Based Authorization with JWT
    1. Include Roles in the JWT Token
            When generating the JWT, include the roles as claims in the payload. These roles can then be used to 
        authorize access to specific endpoints.
        Example JWT payload with roles:
        {
        "sub": "1234567890",
        "name": "John Doe",
        "roles": ["Admin", "User"],
        "exp": 1700000000
        }

        In .NET Core, the Claim object is used to embed roles.
        var claims = new List<Claim>
        {
            new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim(ClaimTypes.Role, "Admin"), // Add roles as claims
            new Claim(ClaimTypes.Role, "User")
        };
    2. Add Authorization in Startup.cs
        Configure JWT authentication and add authorization services.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                .AddJwtBearer(options =>
                {
                    options.TokenValidationParameters = new TokenValidationParameters
                    {
                        ValidateIssuer = true,
                        ValidateAudience = true,
                        ValidateLifetime = true,
                        ValidateIssuerSigningKey = true,
                        ValidIssuer = "yourIssuer",
                        ValidAudience = "yourAudience",
                        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("yourSecretKey"))
                    };
                });

            services.AddAuthorization(options =>
            {
                options.AddPolicy("AdminPolicy", policy => policy.RequireRole("Admin"));
                options.AddPolicy("UserPolicy", policy => policy.RequireRole("User"));
            });

            services.AddControllers();
        }

    3. Protect Endpoints with Roles
        Use the [Authorize] attribute with role requirements.
            [Authorize(Roles = "Admin")]
            [HttpGet("admin-only")]
            public IActionResult AdminOnlyEndpoint()
            {
                return Ok("This endpoint is for Admins only.");
            }

            [Authorize(Roles = "User")]
            [HttpGet("user-only")]
            public IActionResult UserOnlyEndpoint()
            {
                return Ok("This endpoint is for Users only.");
            }

            [Authorize(Roles = "Admin,User")]
            [HttpGet("admin-or-user")]
            public IActionResult AdminOrUserEndpoint()
            {
                return Ok("This endpoint is accessible by both Admins and Users.");
            }

            You can also use policies for fine-grained control:

            [Authorize(Policy = "AdminPolicy")]
            [HttpGet("admin-policy")]
            public IActionResult AdminPolicyEndpoint()
            {
                return Ok("This endpoint is for Admins only (policy-based).");
            }

Example Token Validation Code
    Extract roles from the token:

    [Authorize]
    [HttpGet("get-roles")]
    public IActionResult GetRolesFromToken()
    {
        var userRoles = User.Claims
                            .Where(c => c.Type == ClaimTypes.Role)
                            .Select(c => c.Value);

        return Ok(new { roles = userRoles });
    }

Security Best Practices

    Limit Token Size:
    Include only the necessary claims to reduce token size.

    Validate Roles on the Server:
    Even though roles are in the token, validate their existence in the database if sensitive actions are involved.

    Use HTTPS:
    Always use HTTPS to prevent token interception.

    Implement Token Expiry:
    Set a reasonable expiry time to limit the lifespan of the token.

    Refresh Tokens:
    Use refresh tokens to provide long-term authentication without re-logging in.

1. DefaultAuthenticateScheme
    -Specifies the authentication scheme to use by default for authenticating requests.
    -When a request is received, this scheme is used to validate the user's credentials and populate the 
    HttpContext.User property with the user's identity.

    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;

    This sets the default scheme to JwtBearer, meaning the application will expect a JSON Web Token (JWT) 
        in the request (typically in the Authorization: Bearer <token> header) and use it to authenticate 
        the user.

2. DefaultChallengeScheme        
    Specifies the scheme to use when a challenge is required.
    A challenge happens when the system needs to ask the client for credentials (e.g., redirect to a 
        login page, or return a 401 Unauthorized response for APIs).

        options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;

    This sets the default scheme to JwtBearer, meaning the application will respond to unauthorized 
        access attempts with a 401 Unauthorized status and possibly include a WWW-Authenticate header 
        indicating that JWT-based authentication is expected.

    Why Are Both Used Here?
        In many applications, the default authentication scheme and default challenge scheme are 
    the same because the application uses one mechanism (e.g., JWT) for both authenticating requests and 
    handling unauthorized requests.
    By setting both properties to JwtBearerDefaults.AuthenticationScheme, you're configuring the 

    application to:
    Authenticate users by validating the JWT included in requests.
    Challenge unauthorized users using the JWT mechanism.


Types of Authorization
======================
1. Role-Based Authorization: Enforce access based on user roles (e.g., Admin, User).
    policy.RequireRole("Admin", "Manager");

2. Claim-Based Authorization: Use user claims to enforce policies.
    policy.RequireClaim("Permission", "EditContent");

3.Custom Authorization: Create and enforce your custom logic using custom requirements and handlers.

    Example: Combining Multiple Requirements in a Policy
    You can combine multiple requirements in a single policy.

    services.AddAuthorization(options =>
    {
        options.AddPolicy("AdminWithMinimumAge", policy =>
        {
            policy.RequireRole("Admin");
            policy.Requirements.Add(new MinimumAgeRequirement(30));
        });
    });


what is Authorazation policy
============================
    In .NET Core, Authorization Policies are a way to define and enforce authorization rules for accessing 
resources or performing actions within an application.
-These policies determine whether a user is allowed to perform a specific operation based on claims, roles, 
or other criteria.

Key Concepts of Authorization Policies in .NET Core
---------------------------------------------------
1. Policy: A policy is a set of requirements that a user must satisfy to gain access to a resource.
2. Requirement: A requirement is a condition that a user must meet. A policy can have one or more requirements.
3. Handler: A handler evaluates whether the user meets a specific requirement.
4. Claims: Claims are user data (e.g., roles, permissions, or custom attributes) that can be used in authorization 
            decisions.

Steps to Implement Authorization Policies
-----------------------------------------
1. Register Policies
    Authorization policies are registered in the ConfigureServices method of the Startup.cs file using the 
    AddAuthorization method.

    services.AddAuthorization(options =>
    {
        options.AddPolicy("AdminOnly", policy =>
            policy.RequireRole("Admin")); // Example of a role-based policy

        options.AddPolicy("AgeRequirement", policy =>
            policy.RequireClaim("Age", "18")); // Example of a claim-based policy
    });

2. Apply Policies to Controllers or Actions
    You can enforce policies at the controller or action level using the [Authorize] attribute with the 
    policy name.

    [Authorize(Policy = "AdminOnly")]
    public IActionResult AdminDashboard()
    {
        return View();
    }

    [Authorize(Policy = "AgeRequirement")]
    public IActionResult AgeRestrictedContent()
    {
        return View();
    }

3. Custom Requirements and Handlers
    If built-in requirements (e.g., roles, claims) are not enough, you can create custom requirements 
    and handlers.
    Define a Custom Requirement:
    public class MinimumAgeRequirement : IAuthorizationRequirement
    {
        public int MinimumAge { get; }

        public MinimumAgeRequirement(int minimumAge)
        {
            MinimumAge = minimumAge;
        }
    }

    Implement a Custom Handler:
    public class MinimumAgeHandler : AuthorizationHandler<MinimumAgeRequirement>
    {
        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, MinimumAgeRequirement requirement)
        {
            var dateOfBirthClaim = context.User.FindFirst(c => c.Type == "DateOfBirth");
            if (dateOfBirthClaim != null)
            {
                var dateOfBirth = DateTime.Parse(dateOfBirthClaim.Value);
                int userAge = DateTime.Today.Year - dateOfBirth.Year;
                if (dateOfBirth > DateTime.Today.AddYears(-userAge)) userAge--;

                if (userAge >= requirement.MinimumAge)
                {
                    context.Succeed(requirement);
                }
            }

            return Task.CompletedTask;
        }
    }

    Register the Custom Handler:
    services.AddAuthorization(options =>
    {
        options.AddPolicy("AtLeast18", policy =>
            policy.Requirements.Add(new MinimumAgeRequirement(18)));
    });

    services.AddSingleton<IAuthorizationHandler, MinimumAgeHandler>();

4. Use Policies in Middleware
    You can enforce authorization policies globally or for specific routes using 
    middleware.
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapGet("/restricted", [Authorize(Policy = "AdminOnly")] () => "Admin Content");
    });




what is FallbackPolicy
======================
    The Fallback Policy in ASP.NET Core is a feature introduced to handle requests that 
do not explicitly specify an authorization policy. It acts as a default authorization 
policy that applies when no other policy is configured for a given endpoint.

Why Use a Fallback Policy?
--------------------------
Global Authorization: Enforce a default authorization rule across all endpoints without 
    needing to decorate every controller or action with [Authorize].

Consistency: Ensure that all endpoints are protected by a default rule unless explicitly
    overridden.

Security: Prevent accidental exposure of endpoints that are not explicitly secured.

How to Configure a Fallback Policy

The Fallback Policy is configured in the AddAuthorization method in the ConfigureServices 
    method of the Startup.cs file (or in Program.cs for minimal APIs).

Example 1: Require Authentication Globally
    This example ensures that all endpoints require authentication unless they explicitly 
    allow anonymous access.

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
            .RequireAuthenticatedUser()
            .Build();
    });

    In this case, any endpoint not explicitly decorated with [AllowAnonymous] or 
    [Authorize(Policy = "SpecificPolicy")] will require the user to be authenticated.

    Example 2: Custom Fallback Policy
    You can define a custom fallback policy with specific requirements.

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
            .RequireRole("Admin")
            .RequireClaim("Department", "IT")
            .Build();
    });

    This fallback policy ensures that all endpoints require the user to have the "Admin"
    role and belong to the "IT" department unless overridden.

    Overriding the Fallback Policy
    You can override the fallback policy for specific actions or controllers by using 
    [AllowAnonymous] or specifying other policies with [Authorize].

    Allow Anonymous Access:
    [AllowAnonymous]
    public IActionResult PublicEndpoint()
    {
        return Ok("This endpoint is accessible to everyone.");
    }

    Apply a Specific Policy:
    [Authorize(Policy = "SpecificPolicy")]
    public IActionResult SecureEndpoint()
    {
        return Ok("This endpoint uses a specific policy.");
    }

    Difference Between Fallback Policy and Default Policy
    Fallback Policy:
        -Automatically applies to endpoints without an explicitly assigned authorization policy.
        -Does not affect endpoints with [Authorize] or [AllowAnonymous].

    Default Policy:
        Used as a template for [Authorize] without specifying a policy name.
        For example, [Authorize] will use the default policy if configured.

        services.AddAuthorization(options =>
        {
            options.DefaultPolicy = new AuthorizationPolicyBuilder()
                .RequireAuthenticatedUser()
                .Build();
        });

    Key Difference: The Default Policy is explicitly used when [Authorize] is applied 
    without a policy name, whereas the Fallback Policy is implicitly applied to endpoints 
    without any authorization attribute.

    Summary
        Fallback Policy ensures that all endpoints are secured unless explicitly overridden.
        Useful for creating a baseline authorization rule across the application.
        Allows flexibility by supporting overrides with [Authorize] or [AllowAnonymous].


1. HTTPS Redirection
    HTTPS Redirection is a middleware in ASP.NET Core that automatically redirects all HTTP 
    requests to HTTPS. This ensures secure communication between the client and the server 
    by encrypting the data using SSL/TLS.
Purpose:
    -To force users to connect via a secure HTTPS channel rather than an insecure HTTP connection.
    -Protects sensitive data like login credentials or personal information from being intercepted.

How It Works:
    When a client sends a request over HTTP (e.g., http://example.com), the middleware issues a 
    301 Moved Permanently or 307 Temporary Redirect response to the HTTPS version of the URL 
    (e.g., https://example.com).

Enabling HTTPS Redirection:
    In the Program.cs or Startup.cs, you can add the middleware as follows:    
    app.UseHttpsRedirection();

Configuration:
You can configure HTTPS redirection in appsettings.json:

    "HttpsRedirection": {
    "RedirectStatusCode": 307,  // Use 307 Temporary Redirect instead of 301
    "HttpsPort": 443           // Specify the port for HTTPS
    }

2. HSTS (HTTP Strict Transport Security)
    HSTS is a security feature that tells browsers to only use HTTPS for communication with 
    your site for a specified duration. This prevents attackers from forcing a downgrade to 
    an insecure HTTP connection (a type of attack called SSL stripping).

How It Works:
    When a browser connects to your site over HTTPS for the first time, the server sends 
    an Strict-Transport-Security header in the response. The browser then remembers this 
    policy for the specified duration and will:
    1. Automatically convert all HTTP requests to HTTPS.
    2. Refuse to connect to the site if HTTPS is unavailable.

Enabling HSTS:
    Add the middleware to the Program.cs or Startup.cs file:
    app.UseHsts();

Configuration:
You can customize HSTS settings like this:

    services.AddHsts(options =>
    {
        options.MaxAge = TimeSpan.FromDays(365);       // Enforce HTTPS for 1 year
        options.IncludeSubDomains = true;             // Apply HSTS to subdomains
        options.Preload = true;                       // Indicate HSTS preload inclusion
    });

Why Use Both?
HTTPS Redirection ensures that users who attempt to visit your site over HTTP are 
    redirected to HTTPS.
HSTS ensures that even if the user types http:// in their browser, the browser will 
    remember to always use https://, preventing man-in-the-middle attacks like 
    SSL stripping.


    // Use HSTS in production
    if (!app.Environment.IsDevelopment())
    {
        app.UseHsts();
    }

    // Redirect HTTP to HTTPS
    app.UseHttpsRedirection();


Key Points
1. HTTPS Redirection is reactive (redirects HTTP requests to HTTPS).
2. HSTS is proactive (instructs browsers to only use HTTPS).
3. Together, they ensure robust security for web applications.