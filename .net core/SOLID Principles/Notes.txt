SOLID Principles 
================
"SOLID" is a set of five design patterns, whose main focus is to create loosely coupled,
flexible, maintainable code. 

-Broad goal of SOLID Principle: Reduce dependencies of various class / modules of the application

Single Responsibility Principle (SRP)
    -> A software module or class should have one-and-only reason to change
    -> i.e one class should do only one task it should not involve in multiple tasks 


Open-Closed Principle (OCP)
    -> A class is closed for modification: but open for extension.
    -> instead of making changes to the existing code base it is advisable to implement 
        the same as a separate class. you may reuse the code via inheritance or through 
        interfaces 
    -> you should not make changes into the existing code base unless you want to 
        fix the bugs 


Liskov Substitution principle (LSP)
    -> Subtypes must be substitutable for their base types. 
    -> subtypes should not override any existing methods of the base class in case they 
        override the existing functionalty of the base class should not be changed 
        the method signature the return value and the exceptions should be exactly matched 
        with the same base type 

Interface Segregation Principle (ISP)
    -> No client class should be forced to depend on methods it does not use.
    -> instead of creating a large interface with multiple methods, create same 
        as smaller and simple interfaces. i.e. create one interface of one 
        specific functionality 

Dependency Inversion Principle (DIP)
    -> High-level modules should not depend on low-level modules. Both should depend 
        upon abstractions. 





Dependency Inversion Principle 
==============================
Direct Dependency 
-----------------

Controller (Client)
public class MyController : Controller 
{
    private readonly MyService _service;
    public MyController()
    {
        _service = new MyService(); //direct
    }
    public IActionResult ActionMethod()
    {
        _service.ServiceMethod();
    }
}

Service (Dependency)
public class MyService 
{
    public void ServiceMethod()
    {
        ...
    }
}


Dependency Problem 
------------------
    -Higher-level modules depend on lower-level modules.
    -Means, both are tightly-coupled 

-The developer of higher-level module Should WAIT until the completion of development of 
    lower-level module.
-Any changes made in the lower-level module effects changes in the higher-level module.
-Requires much code changes in to interchange an alternative lower-level module.
-Difficult to test a single module without effecting/testing the other module.

Dependency Inversion Principle 
------------------------------
    Dependency Inversion Principle (DIP) is a design principle (guideline), which is 
a solution for the dependency Problem.

"The higher-level modules (clients) SHOULD NOT depend on low-level modules (dependencies).
Both should depend on abstractions (interfaces or abstract class)".

"Abstractions should not depend on details (both client and dependency).
Details (both client and dependency) should depend on abstractions."

-The interface is controlled by the client 
-Both client and dependency depend on abstraction.


Controller (Client)
-------------------
public class MyController : Controller 
{
    private readonly IService _service;
    public MyController(IService service)
    {
        _service = service; //object from Ioc container 
    }
    public IActionResult ActionMethod()
    {
        _service.ServiceMethod();
    }
}

Method(Client)
--------------
public class MyController: Controller
{
    public IActionResult ActionMethod(
        [FromServices] IService service)
    {
        service.ServiceMethod();
    }
}



Single Responsibility Principle 
===============================
-A class should implement only one functionality.

-Avoid multiple / tightly coupled functionalities in single class.
-Benefit: Makes the class independent of other classes, in terms of its purpose/functionality.
    So that, the classes become easier to design, write, debug, maintain and test 

Eg: 
A class that performs validation should only involve in validation. 
But it should not read configuration settings from a configuration file.
But instead, it call a method of another class that reads configuration settings.



Interface Segregation Principle (ISP)
=====================================
Interface1
public interface Interface1
{
    void Method1(); //performs one task 
    void Method2();//performs a different task 
}
-should be re-written as 

Interface1
public interface Interface1
{
    void Method1();
}

Interface2 
public interface Interface2
{
    void Method2();
}


-No client class should be forced to depend on methods it doesn't use. 
-We should prefer to make many smaller interfaces rather than one single big interface 

-The client classes may choose one or more interfaces to implement.
-Benefit: Makes it easy to create alternative implementation for a specific functionality, 
    rather than creating entire class.


Eg: 
Assume, a class has two methods: GetPersons() and AddPerson().
Instead of creating both methods in a single interface, create them as two different
interfaces: IPersonGetter, IPersonAdder 

-interface - IPersonsGetter (methods to get person data) 
-interface - IPersonsAdder (methods to create person) 


ISP in Tests 
============



Open / Closed Principle 
=======================

Interface 
public class Interface1
{
    void Method1();
}

public class Class1 : Interface1 
{
    void Method(){} //performs one task 
}

-When modification is needed: The code should be reimplemented as 

ModifiedClass1
public class Modified1 : Interface1 
{
    void Method(){} //recreate code 
}


-if you want to update one method in the existing service then create one more service 
    implement the same interface inject the existing service into the new service 
    and call same methods which we don't want to change and change implementation 
    of the method which we want to change.

-and inject old service directly with class name and not with interface 
    and new service inject with the interface because this will be used by the clients 
    now 
    //old service 
        services.AddScoped<PersonGetterService, PersonGetterService>();
        service.AddScoped<IPersonGetterService, PersonGetterServiceWithFewExcelFields>();

-A class is closed for modifications; but open for extension.
 You should treat each class as readonly for development means; unless for bug-fixing.

-If you want to extend / modify the functionality of an existing class; you need to 
    recreate it as a separate & alternative implementation; rather than modifying 
    existing code of the class. 

Benefit: 
    Not modifying existing code of class does'nt introduce new bugs; and keeps the existing
unit test stay relavant and need no changes.

Eg: 
Assume, a class has a method: GetPerson().
The new requirement is to get list of sorted persons.
Instead of modifying existing GetPerson() method, you need to create an alternative 
    class that gets stored persons list.

class 
PersonGetter : IPersonGetter 
    (GetPersons() method retrieves list of persons)

class 
SortedPersonGetter : IPersonGetter 
    (getPersons() method retrieves sorted list of persons)


OCP with Inheritance 
====================
Interfaces 
----------
    Create alternative implementation of the class by implementing the same interface 

Inheritance 
-----------
    Create a child class of the existing class and override the required method that 
    needs changes.

-make all methods virtual in the existing class so that we can override those in 
    child class. 

public class PersonsGetterServiceChild : PersonGetterService
{
    //override the particular method 
}

-and updated the dependency 
    service.AddScoped<IPersonGetterService, PersonGetterServiceChild>();

-Using interface is recommended way and not the inheritance -> because it may violate LSP
 ---------------------------------------------------------



Liskov Substitution Principle (LSP)
=============================

Parent Class 

public class ParentClass 
{
    public virtual int Calculate(int? a, int? b)
    {
        //if 'a' or 'b' is null,
                throw ArgumentNullException 
        //return sum of 'a' and 'b'
    }
}

Child Class 

public class ChildClass : ParentClass 
{
    public override int Calculate(int? a, int b)
    {
        //if 'a' or 'b' is null,
                throw ArgumentNullException 
        //if 'a' or 'b' is negative                 //Violates LSP
                throw ArgumentNullException         //Violates LSP
        //return product of 'a' and 'b'             //Violates LSP 
    }
}


-Functions that use reference of base classes must be able to use objects 
    of derived classes without breaking / changing its functionality. 
-The child classes that override methods of base class, should provide same behavior.

-> Using object of parent class 
    ParentClass variable = new ParentClass();
    variable.Method(); //executes ParentClass.Method 

->Using object of child class 
    ParentClass variable = new ChildClass();
    variable.Method(); //executes ChildClass.Method 

->[Both methods should offer same functionality]


-If a derived class overrides a method of base class; then the method of derived 
    class should provide same behavior:
    - With same input, it should provide same output (return value).
    - The child class's method should not introduce (throw) any new exceptions 
        than what were thrown in the base implementation.
    - The child class's method should not implement stricter rules than base 
        class's implementation.

Benefit: Prevents code to break - if mistake or wantedly, someone has replaced the 
            derived class with its base class(or even vice versa), as its behavior 
            doesn't change.